Web Concepts

本节演示了根据浏览器类型如何使用PHP可以提供动态页面内容，像随机生成的数字或用户输入。它还展示了客户端浏览器是怎么可以被重定向的。

识别浏览器&平台
PHP 创建一些有用的环境变量,它们可以在用于设置 php 环境的 phpinfo.php 页面中看到 PHP 配置。

被 PHP 设置环境变量集中一个变量 HTTP_USER_AGENT 是用来标识用户的浏览器和操作系统。

PHP 提供了 getenv() 函数来访问所有的环境变量的值。

HTTP_USER_AGENT 环境变量中包含的信息适合于浏览器，可用于创建动态内容。

下面的例子演示了如何识别客户浏览器和操作系统。

注意:函数 preg_match() 是在 PHP 正则表达式匹配函数

    <html>
    <body>
    <?php
       $viewer = getenv( "HTTP_USER_AGENT" );
       $browser = "An unidentified browser";
       if( preg_match( "/MSIE/i", "$viewer" ) )
       {
          $browser = "Internet Explorer";
       }
       else if(  preg_match( "/Netscape/i", "$viewer" ) )
       {
          $browser = "Netscape";
       }
       else if(  preg_match( "/Mozilla/i", "$viewer" ) )
       {
          $browser = "Mozilla";
       }
       $platform = "An unidentified OS!";
       if( preg_match( "/Windows/i", "$viewer" ) )
       {
          $platform = "Windows!";
       }
       else if ( preg_match( "/Linux/i", "$viewer" ) )
       {
          $platform = "Linux!";
       }
       echo("You are using $browser on $platform");
    ?>
    </body>
    </html>
这是在我的机器上产生后的结果。可能在不同的电脑依据所运行的环境会产生不同的结果。

    You are using Mozilla! on Windows!
随机显示图像


PHP rand() 函数用于生成一个随机数。这个函数可以会随机地在一个给定的范围内生成数字。随机数生成器打乱数字生成的规律。通过使用srand()函数，给它特定的种子数值作为它的参数。

以下示例演示了如何每次显示四个不同的图像的图片:

    <html>
    <body>
    <?php
      srand( microtime() * 1000000 );
      $num = rand( 1, 4 );

      switch( $num ) 
      {
      case 1: $image_file = "/home/images/alfa.jpg";
              break;
      case 2: $image_file = "/home/images/ferrari.jpg";
              break;
      case 3: $image_file = "/home/images/jaguar.jpg";
              break;
      case 4: $image_file = "/home/images/porsche.jpg";
              break;
      }
      echo "Random Image : <img src=$image_file />";
    ?>
    </body>
    </html>
使用 HTML 表单
最重要的事情是需要注意在处理 HTML 表单和 PHP 页面时，任何形式的表单元素都会提交到您的 PHP 脚本。试试下面的例子将在源代码 test.php 脚本运行。

    <?php
      if( $_POST["name"] || $_POST["age"] )
      {
         echo "Welcome ". $_POST['name']. "<br />";
         echo "You are ". $_POST['age']. " years old.";
         exit();
      }
    ?>
    <html>
    <body>
      <form action="<?php $_PHP_SELF ?>" method="POST">
      Name: <input type="text" name="name" />
      Age: <input type="text" name="age" />
      <input type="submit" />
      </form>
    </body>
    </html>
PHP 他默认变量 $ _PHP_SELF 用于输出 PHP 脚本名称，当你点击“提交”按钮时然后，PHP 脚本将被调用，将会产生以下结果:
method=“POST” 用于用户发送数据到服务器脚本。在 PHP 中有两个方法可以上传数据到服务器脚本，GET 和 POST 将在以后的章节讨论。
浏览器重定向
PHPheader()函数提供原始 HTTP headers 到浏览器，可用于重定向到另一个位置。重定向脚本应该在页面的顶端，以防止加载页面的其他部分。

Location:用来指定目标位置：header()函数使用 url 作为参数。在调用该函数之后使用exit() 函数可以阻止其他代码的解析

下面的例子演示了如何将浏览器请求重定向到另一个 web 页面。试试这个例子 test.php 源代码的脚本。

    <?php
      if( $_POST["location"] )
      {
         $location = $_POST["location"];
         header( "Location:$location" );
         exit();
      }
    ?>
    <html>
    <body>
       <p>Choose a site to visit :</p>
       <form action="<?php $_PHP_SELF ?>" method="POST">
       <select name="location">
          <option value="http://w3c.org">
                World Wise Web Consortium
          </option>
          <option value="http://www.google.com">
                Google Search Page
          </option>
       </select>
       <input type="submit" />
       </form>
    </body>
    </html>
显示“文件下载”对话框
某个时候显示“文件下载”对话框是想要的功能，你想给使用选项当用户点击一个链接，它就会弹出一个“文件下载”显示框给用户而不是显示实际内容。通过 HTTP 头协议这是非常容易的。

HTTP 头协议将不同于实际的协议，我们发送的 Content-Type为text/htmlnn。在这种情况下，将application/octet-stream和实际文件名称将连接到一起。

例如，如果你想要从一个给定的文件名文件下载链接，那么它的语法将如下。

    #!/usr/bin/perl
    # HTTP Header
    print "Content-Type:application/octet-stream; name=\"FileName\"\r\n";
    print "Content-Disposition: attachment; filename=\"FileName\"\r\n\n";

    # Actual File Content
    open( FILE, "<FileName" );
    while(read(FILE, $buffer, 100) )
    {
       print("$buffer");
    }



GET 和 POST 方法

浏览器客户端有两种方法可以将信息发送到 web 服务器。　

GET 方法　
POST 方法
浏览器发送信息之前,它的编码使用的一种是被称为 URL 编码的方案。在这个方案中, 使用名称/值与 & 不分离的方式。

    name1=value1&name2=value2&name3=value3
空格会被删除,取而代之的是+字符和其他任何非字母数字字符替换为十六进制值。信息编码后发送到服务器。

$_GET 变量
GET方法发送编码用户信息添加到页面请求。页面和编码信息是由?字符分开。

    http://www.test.com/index.htm?name1=value1&name2=value2
$_GET 方法会在你的服务器日志输出一个长字符串，出现在浏览器的位置：box 框。
GET 方法仅局限于发送高达 1024 个字符。
如果你有密码或其他敏感信息，从不使用 GET 方法发送到服务器。
不能被用来发送二进制数据，如图像或 word 文档,到服务器。
GET 方法发送的数据可以使用 QUERY_STRING 环境变量访问。
PHP 提供了关联数组$_GET可以访问所有使用 GET 方法的发送信息。
试试下面的例子的源代码 test.php 脚本。

    <?php
      if( $_GET["name"] || $_GET["age"] )
      {
         echo "Welcome ". $_GET['name']. "<br />";
         echo "You are ". $_GET['age']. " years old.";
         exit();
      }
    ?>
    <html>
    <body>
      <form action="<?php $_PHP_SELF ?>" method="GET">
      Name: <input type="text" name="name" />
      Age: <input type="text" name="age" />
      <input type="submit" />
      </form>
    </body>
    </html>
$_POST 变量
POST 方法通过 HTTP headers 头转移信息。信息被编码可以描述为在 GET 方法的情况下,把信息放入一个 header 头称为 QUERY_STRING。。

POST 方法没有任何要发送的数据大小限制。
可以使用 POST 方法发送 ASCII 和二进制数据。
POST 方法发送的数据通过 HTTP 头，所以安全依赖于 HTTP 协议。通过使用安全 HTTP 可以确保您的信息安全。
PHP 提供了 $ _POST 关联数组访问所有使用 POST 方法发送信息。
试试下面的例子在源代码 test.php 脚本中。

    <?php
      if( $_POST["name"] || $_POST["age"] )
      {
         echo "Welcome ". $_POST['name']. "<br />";
         echo "You are ". $_POST['age']. " years old.";
         exit();
      }
    ?>
    <html>
    <body>
      <form action="<?php $_PHP_SELF ?>" method="POST">

      Name: <input type="text" name="name" />
      Age: <input type="text" name="age" />

      <input type="submit" />
      </form>
    </body>
    </html>
$_REQUEST 变量
PHP 的 $_REQUEST 变量包含了 $_GET, $_POST 以及 $_COOKIE 的内容。

PHP 的 $_REQUEST 变量可用来取得通过 GET 和 POST 方法发送的表单数据的结果。

试试下面的例子在源代码 test.php 脚本中。

    <?php
      if( $_REQUEST["name"] || $_REQUEST["age"] )
      {
         echo "Welcome ". $_REQUEST['name']. "<br />";
         echo "You are ". $_REQUEST['age']. " years old.";
         exit();
      }
    ?>
    <html>
    <body>
      <form action="<?php $_PHP_SELF ?>" method="POST">

      Name: <input type="text" name="name" />
      Age: <input type="text" name="age" />

      <input type="submit" />
      </form>
    </body>
    </html>
这里，$_PHP_SELF 变量包含自我脚本的名称。




文件包含

在服务器执行它之前，您可以在一个 PHP 文件中包含另一个 PHP 文件的内容。有两个 PHP 函数,可用于包括一个 PHP 文件到另一个 PHP 文件。

include() 函数
require() 函数
这是 php 重要的知识点用于可在多个页面重复使用的函数、页眉、页脚或元素。这会为开发者节省大量的时间。这意味着您可以创建供所有网页引用的标准页眉或菜单文件。当页眉需要更新时，您只更新一个包含文件就可以了，或者当您向网站添加一张新页面时，仅仅需要修改一下菜单文件（而不是更新所有网页中的链接）。

include() 函数
include() 函数可获得指定文件中的所有文本，并把文本拷贝到使用 include 函数的文件中。include() 函数会生成一个警告，但是脚本会继续执行。

假设您希望创建一个共同的菜单为您的网站。然后创建一个 menu.php 使用以下内容。

    <a href="http://www.tutorialspoint.com/index.htm">Home</a> - 
    <a href="http://www.tutorialspoint.com/ebxml">ebXML</a> - 
    <a href="http://www.tutorialspoint.com/ajax">AJAX</a> - 
    <a href="http://www.tutorialspoint.com/perl">PERL</a> <br />
你现在想创建尽可能多的页面,包括这个文件创建标题。例如现在您的test.php文件可以有以下内容。

    <html>
    <body>
    <?php include("menu.php"); ?>
    <p>This is an example to show how to include PHP file!</p>
    </body>
    </html>
这个文件会输出以下结果：

    Home - ebXML - AJAX - PERL 
这是一个示例来展示如何使用 PHP 文件包含。您可以包含更多你需要包函的 menu.php 文件!

require() 函数
require()函数接受的所有文本文件,并将它复制到指定的文件中，使用了包括功能。如果在加载一个文件时有任何问题，require()函数生成一个致命错误,停止脚本的执行。

require() 函数与 include()除了它对错误的处理方式不同其他都相同。include() 函数会生成一个警告，但是脚本会继续执行，而 require() 函数会生成一个致命错误（fatal error）在错误发生后脚本会停止执行。 你可以尝试用以上示例 include()函数，它会产生相同的结果。但是如果你运行以下两个例子，文件不存在，那么你会得到不同的结果。

    <html>
    <body>
    <?php include("xxmenu.php"); ?>
    <p>This is an example to show how to include wrong PHP file!</p>
    </body>
    </html>
这个文件会输出以下结果：

    This is an example to show how to include wrong PHP file!
现在，让我们使用 require() 函数运行相同的例子。

    <html>
    <body>
    <?php require("xxmenu.php"); ?>
    <p>This is an example to show how to include wrong PHP file!</p>
    </body>
    </html>
这一次文件执行中断并没有显示出任何内容。

注意:您可能会得到简单的警告消息或致命错误消息或一无所有。这取决于您的 PHP 服务器配置。



文件 I/O

本章将解释以下函数相关文件:

打开一个文件
阅读一个文件
写一个文件
关闭一个文件
打开和关闭文件
PHP fopen()函数用于打开一个文件。它需要两个参数声明文件名称和操作模式。

可以指定文件模式的六个选项在这个表。

模式	用法
r	打开文件仅供阅读。将指针放到文件的开头。
r+	打开文件进行阅读和写作。将指针放到文件的开头。
w	打开文件仅供编写。将指针放到文件的开头。如果文件不存在它将创建一个文件存在。
w+	打开文件仅供阅读和写作。将指针放到文件的开头。如果文件不存在它将创建一个文件存在。
a	打开文件仅供编写。将指针放到文件的结尾。如果文件不存在它将创建一个文件存在。
a+	打开文件仅供阅读和写作。将指针放到文件的结尾。如果文件不存在它将创建一个文件存在。
如果试图打开一个文件失败然后 fopen 返回一个 false 值，否则它返回一个文件指针用于进一步阅读或写文件。

打开文件做出更改之后使用 fclose() 函数关闭它是很重要的。fclose() 函数需要一个文件指针作为参数，然后关闭成功返回 true，如果关闭不能成功返回假。

阅读文件
一旦使用 fopen() 函数打开一个文件可以调一个函数 fread() 用于读文件。这个函数需要两个参数。这些参数都是必须的，文件指针和文件表示的长度字节。

文件的长度可以使用 filesize() 函数，此函数将文件名作为参数，并返回文件用字节所表示的大小。

这里是用 PHP 读取文件所需的步骤。　　　　

打开一个文件使用 fopen() 函数。　　　　
得到文件的长度使用 filesize() 函数。　　　　
读取文件的内容使用 fread() 函数。　　　　
关闭文件和 fclose() 函数。
下面的例子将文本文件的内容赋给一个变量然后在 web 页面上显示这些内容。

    <html>
    <head>
    <title>Reading a file using PHP</title>
    </head>
    <body>

    <?php
    $filename = "/home/user/guest/tmp.txt";
    $file = fopen( $filename, "r" );
    if( $file == false )
    {
       echo ( "Error in opening file" );
       exit();
    }
    $filesize = filesize( $filename );
    $filetext = fread( $file, $filesize );

    fclose( $file );

    echo ( "File size : $filesize bytes" );
    echo ( "<pre>$filetext</pre>" );
    ?>

    </body>
    </html>
写一个文件
使用 PHP fwirte() 函数可以编写一个新文件或文本到附加的现有文件里。该函数需要两个参数指定一个文件指针的字符串被写入的数据。可选的第三个整数参数可以包含指定写入数据的长度。如果第三个参数被包含,指定的长度写完后操作就会停止。

下面的示例创建一个新的文本文件然后在里面写一个简短的文本标题。关闭这个文件后它的存在与否可以使用 file_exist() 函数并且将文件名作为参数。

    <?php
    $filename = "/home/user/guest/newfile.txt";
    $file = fopen( $filename, "w" );
    if( $file == false )
    {
       echo ( "Error in opening new file" );
       exit();
    }
    fwrite( $file, "This is  a simple test\n" );
    fclose( $file );
    ?>

    <html>
    <head>
    <title>Writing a file using PHP</title>
    </head>
    <body>

    <?php
    if( file_exist( $filename ) )
    {
       $filesize = filesize( $filename );
       $msg = "File  created with name $filename ";
       $msg .= "containing $filesize bytes";
       echo ($msg );
    }
    else
    {
       echo ("File $filename does not exit" );
    }
    ?>
    </body>
    </html>
我们已经介绍了所有相关的文件函数输入和 PHP 系统函数章节。



函数

PHP 函数类似于其他编程语言。函数是一段代码将以输入参数的形式做一些处理操作，并返回一个值。

你已经见过许多函数例如 fopen() 和 fread() 等。他们都是内置函数，但你可以自己选择创建自己的函数。

你应该清楚两个部分: 　

创建一个 PHP 函数
调用一个 PHP 函数
事实上，你几乎不需要创建自己的 PHP 函数，因为已经有超过 1000 个的内置库函数在不同的区域被创建，你只需要根据您的需求调用他们。

请参阅一套完整的有用的 [PHP Function Reference]() 函数。

创建 PHP 函数
它非常容易创建自己的 PHP 函数。假设您希望创建一个 PHP 函数, 当你调用它时，只需编写一个简单的消息显示在你的浏览器上面。以下示例创建了一个名为 writeMessage() 的函数，只是在创建它之后调用它。

注意，在创建一个函数的名字时应该在开头使用关键字 function 并且把所有的 PHP 代码放在{and}括号内。如下面的例子所示：

    <html>
    <head>
    <title>Writing PHP Function</title>
    </head>
    <body>

    <?php
    /* Defining a PHP Function */
    function writeMessage()
    {
      echo "You are really a nice person, Have a nice time!";
    }
    /* Calling a PHP Function */
    writeMessage();
    ?>
    </body>
    </html>    
这将显示以下结果:

    You are really a nice person, Have a nice time!
PHP 函数的参数
PHP 给你选择往函数里传递参数。你可以传递多个参数。这些参数的工作方式就像你的函数里面内部变量。以下示例有两个整数参数，并将它们添加在一起，然后打印。

    <html>
    <head>
    <title>Writing PHP Function with Parameters</title>
    </head>
    <body>

    <?php
    function addFunction($num1, $num2)
    {
      $sum = $num1 + $num2;
      echo "Sum of the two numbers is : $sum";
    }
    addFunction(10, 20);
    ?>
    </body>
    </html>
这将显示以下结果：

    Sum of the two numbers is : 30
按引用传递参数
可以将参数作为引用传递给函数。这意味着函数可以操作变量引用，而不是对一个变量值的副本的操作。

在这些情况下一个参数的任何变化都会改变原来的变量的值。您可以通过在变量名称前加&符号传递一个参数引用变量，在函数调用时或函数定义时。

下面的例子描述了这两个情况。

    <html>
    <head>
    <title>Passing Argument by Reference</title>
    </head>
    <body>
    <?php
    function addFive($num)
    {
       $num += 5;
    }

    function addSix(&$num)
    {
       $num += 6;
    }
    $orignum = 10;
    addFive( &$orignum );
    echo "Original Value is $orignum<br />";
    addSix( $orignum );
    echo "Original Value is $orignum<br />";
    ?>
    </body>
    </html>
这将显示以下结果：

    Original Value is 15
    Original Value is 21
PHP 函数返回值
一个函数可以使用返回语句返回一个值与对象。函数返回值时会停止执行 return 语句后代码并将值返回给调用的代码。

你可以使用 return array(1,2,3,4)从一个函数返回多个值。

以下示例有两个整数参数，并将它们添加在一起,然后返回调用程序的总和。注意，return 关键字用于从一个函数返回一个值。

    <html>
    <head>
    <title>Writing PHP Function which returns value</title>
    </head>
    <body>

    <?php
    function addFunction($num1, $num2)
    {
      $sum = $num1 + $num2;
      return $sum;
    }
    $return_value = addFunction(10, 20);
    echo "Returned value from the function : $return_value";
    ?>
    </body>
    </html>
这将显示以下结果：

    Returned value from the function : 30
设置函数参数的默认值
如果函数的调用者没有传递值给这个参数，你可以设置默认值给这个参数。

函数输出空,以防没有任何参数值传递给这个函数。

    <html>
    <head>
    <title>Writing PHP Function which returns value</title>
    </head>
    <body>

    <?php
    function printMe($param = NULL)
    {
       print $param;
    }
    printMe("This is test");
    printMe();
    ?>

    </body>
    </html>
这将显示以下结果：

    This is test
动态函数调用
可以分配函数名给一个字符串变量，然后将这些变量指向函数名称本身。下面的例子描述了这种行为。

    <html>
    <head>
    <title>Dynamic Function Calls</title>
    </head>
    <body>
    <?php
    function sayHello()
    {
       echo "Hello<br />";
    }
    $function_holder = "sayHello";
    $function_holder();
    ?>
    </body>
    </html>
这将显示以下结果：

    Hello



Cookies

Cookies 是文本文件存储在计算机客户端, 目的是用来跟踪用户的。PHP 完全地支持 HTTP cookie。

有三个步骤参与识别返回用户： 　 　　　

服务器脚本向浏览器发送一系列 cookies。例如姓名、年龄、身份证号码等。　　　　
浏览器将这个信息存储在本地机器上,以供将来使用。　　　　
下次当浏览器向web服务器发送任何请求然后浏览器将这些 cookie 信息发送给服务器,服务器使用这些信息来识别用户。
本章将教你如何设置 cookie，如何访问它们，以及如何删除它们。

一个 cookie 的剖析
cookie 通常设置在一个 HTTP 头信息里面(尽管 JavaScript 浏览器也可以直接设置 cookie)。一个 PHP 脚本，设置cookie 发送头信息看起来是这样的：

    HTTP/1.1 200 OK
    Date: Fri, 04 Feb 2000 21:03:38 GMT
    Server: Apache/1.3.9 (UNIX) PHP/4.0b3
    Set-Cookie: name=xyz; expires=Friday, 04-Feb-07 22:03:38 GMT; 
                     path=/; domain=tutorialspoint.com
    Connection: close
    Content-Type: text/html
如您所见，Set-Cookie 头包含一个名称值对,格林尼治时间日期、路径和一个域名。名称和值将由 URL 编码。到期字段是“forget”的指令到浏览器 cookie 在给定的时间和日期。

如果浏览器配置存储 cookies，然后它会保存这个信息直到日期过期。如果用户点浏览器在任何页面并且和 cookie 的路径和域名相匹配,那么它将重新发送 cookie 到服务器。浏览器的标题看起来是这样的：

    GET / HTTP/1.0
    Connection: Keep-Alive
    User-Agent: Mozilla/4.6 (X11; I; Linux 2.2.6-15apmac ppc)
    Host: zink.demon.co.uk:1126
    Accept: image/gif, */*
    Accept-Encoding: gzip
    Accept-Language: en
    Accept-Charset: iso-8859-1,*,utf-8
    Cookie: name=xyz
一个 PHP 脚本将访问环境变量的 $_COOKIE 或持有所有 cookie 的名称和值 d 的 $HTTP_COOKIE_VARS[]。以上 cookie 可以使用 $HTTP_COOKIE_VARS["name"]。

在 PHP 中设置 cookie
PHP 提供了 setcookie()函数来设置 cookie。该函数需要高达六个参数,应该在 <html>标记之前调用。每个cookie 分别必须调用此函数。

    setcookie(name, value, expire, path, domain, security);
这是详细的参数: 　 　　　

Name——这设置 cookie 的名称和存储在一个名为 HTTP_COOKIE_VARS 的环境变量。这个变量是在访问使用cookie。　　　　
Value——指定变量的值,是你实际想要存储的内容。　　　　
Expiry——这指定一个未来的时间以秒为单位就是从 1970 年 1 月 1 日格林尼治时间之后。这个时间之后 Cookie 将无法访问。如果 cookie 里面没有设置这个参数，Web 浏览器关闭时将自动过期。　　　　
Path——指定目录中 cookie 是有效的。一个正斜杠字符允许所有目录的 cookie 有效。　　　　
Domain——这可以在非常大的领域里用来指定域名在并且必须包含至少两个有效的时期。创建 Cookie 都是唯一有效的主机和域名。
Security——这可以设置为1可以指定发送的 cookie 只能使用 HTTPS 安全传输，否则设置为 0 意味着可以定期发送的 HTTP cookie。
以下示例将创建两个 cookies name 和 age，这些 cookie 将一小时后过期。

    <?php
       setcookie("name", "John Watkin", time()+3600, "/","", 0);
       setcookie("age", "36", time()+3600, "/", "",  0);
    ?>
    <html>
    <head>
    <title>Setting Cookies with PHP</title>
    </head>
    <body>
    <?php echo "Set Cookies"?>
    </body>
    </html>
使用 PHP 访问 Cookies
PHP 提供了许多方法来访问 cookie。最简单的方法是使用 $_COOKIE 或 $HTTP_COOKIE_VARS 变量。

以下示例将访问所有的上面的例子中的 cookie。

    <html>
    <head>
    <title>Accessing Cookies with PHP</title>
    </head>
    <body>
    <?php
    echo $_COOKIE["name"]. "<br />";
    /* is equivalent to */
    echo $HTTP_COOKIE_VARS["name"]. "<br />";

    echo $_COOKIE["age"] . "<br />";
    /* is equivalent to */
    echo $HTTP_COOKIE_VARS["name"] . "<br />";
    ?>
    </body>
    </html>
您可以使用 isset()函数检查是否设置 cookie。

    <html>
    <head>
    <title>Accessing Cookies with PHP</title>
    </head>
    <body>
    <?php
      if( isset($_COOKIE["name"]))
        echo "Welcome " . $_COOKIE["name"] . "<br />";
      else
        echo "Sorry... Not recognized" . "<br />";
    ?>
    </body>
    </html>
使用 PHP 删除 Cookie
正式地删除一个 cookie 应该使用 setcookie()函数的 name 参数但是这样工作总是不好，然而不应该有依赖。

最安全的方法是设置 cookie 的日期已经过期:

    <?php
      setcookie( "name", "", time()- 60, "/","", 0);
      setcookie( "age", "", time()- 60, "/","", 0);
    ?>
    <html>
    <head>
    <title>Deleting Cookies with PHP</title>
    </head>
    <body>
    <?php echo "Deleted Cookies" ?>
    </body>
    </html>



绘话技术

另一种方法是使用 PHP 会话，使数据可访问整个网站的各个页面。

一个会话在服务器上的一个临时目录中创建了一个文件用来存储会话变量及其值。这些数据将可以在网站的所有页面中被访问到。

临时文件的位置是在 php.ini 文件中称为 session.save_path 中设置的。确保使用任何会话变量之前确定你已经设置这条路径。

当一个会话启动需要做以下事情： 　 　

PHP 特定会话首先会创建一个惟一的标识符，这个标识符是一个随机的 32 伪十六进制数字的字符串3c7foj34c3jj973hjkop2fc937e3443。　　　　

一个 cookie 调用 PHPSESSID 自动发送到用户的电脑存储独特的会话识别的字符串。

在指定服务器上会自动创建临时目录里的文件，这个文件存储名称前缀为 sess_ 的 sess_3c7foj34c3jj973hjkop2fc937e3443的唯一标识符。
当 PHP 脚本要检索一个会话变量中的值，PHP 会自动获得独特的会话标识符的字符串 PHPSESSID cookie，然后在其临时目录的文件中可以通过比较两个值进行验证。

当用户关闭了浏览器或离开浏览器后会话结束, 一般在预定时间后 30 分钟，服务器将终止该会话。

开始一个 PHP 会话
通过调用 session_start()函数一个 PHP 会话很容易开启。这个函数首先检查如果已经开始一个会话或者没有开始会话那么开启一个会话。建议把调用 session_start() 函数放在页面的头部。

会话变量存储在名为 $ _SESSION[]的关联数组中。这些变量可以在一个会话的生命周期内被访问。

下面的例子开始一个会话然后注册一个变量 counter，会话期间每次访问页面可以加载这个变量。

把这段代码放在 test.php 文件中然后加载这个文件多次查看结果：

把这段代码放在 test.php 文件中然后加载这个文件多次查看结果：

    <?php
       session_start();
       if( isset( $_SESSION['counter'] ) )
       {
          $_SESSION['counter'] += 1;
       }
       else
       {
          $_SESSION['counter'] = 1;
       }
       $msg = "You have visited this page ".  $_SESSION['counter'];
       $msg .= "in this session.";
    ?>
    <html>
    <head>
    <title>Setting up a PHP session</title>
    </head>
    <body>
    <?php  echo ( $msg ); ?>
    </body>
    </html>
销毁一个 PHP 会话
使用 session_destroy() 函数可以使一个 PHP 会话被销毁。这个函数不需要任何参数，单个调用就可以摧毁所有会话变量。如果你想要摧毁一个会话变量，那么你可以使用 unset() 函数来删除一个会话变量。

这是示例删除一个变量：

    <?php
       unset($_SESSION['counter']);
    ?>
这是函数将会摧毁所有的会话变量：

    <?php
       session_destroy();
    ?>
打开自动会话
如果你在 PHP.INI 文件中设置 session.auto_start 变量为 1，当用户访问你的网站时你不需要调用 start_session() 函数来启动一个会话。

Sessions 是基于 Cookie 的
或许有这么一种情况当用户不允许在他们的机器中存储 cookies 时。所以还有另一个方法将 sessionID 发送到浏览器。

或者，您可以使用常数 SID 如果会话开始时被定义。如果客户端没有发送一个合适的会话 cookie，它的形式是session_name = session_id。不然，它会填充到一个空字符串。因此，你可以无条件地嵌入到 urls。

下面的例子演示了如何注册一个变量，以及如何使用 SID 正确的链接到另一个页面。

    <?php
       session_start();

       if (isset($_SESSION['counter'])) {
          $_SESSION['counter'] = 1;
       } else {
          $_SESSION['counter']++;
       }
    ?>
       $msg = "You have visited this page ".  $_SESSION['counter'];
       $msg .= "in this session.";
       echo ( $msg );
    <p>
    To continue  click following link <br />
    <a  href="nextpage.php?<?php echo htmlspecialchars(SID); >">
    </p>
当打印 SID 时函数 htmlspecialchars() 为了防止 XSS 攻击。



邮件发送

必须正确配置 PHP 中 PHP.ini 文件中如何详细地使用系统发送电子邮件。打开php.ini文件中可用 /etc/目录，找到部分[邮件函数]。

Windows 用户应该确保提供两个指令。第一个叫做 SMTP，它定义了你的电子邮件服务器地址。第二个叫做 sendmail_from 定义您自己的电子邮件地址。

配置 Windows 看起来应该是这样的：

    [mail function]
    ; For Win32 only.
    SMTP = smtp.secureserver.net

    ; For win32 only
    sendmail_from = webmaster@tutorialspoint.com
Linux 用户只需要告诉 PHP 他们的sendmail 的应用程序位置。指定的路径和任何所需的开关应该在 sendmail_path 有所指引。

Linux 的配置应该是这样的：

    [mail function]
    ; For Win32 only.
    SMTP =

    ; For win32 only
    sendmail_from =

    ; For Unix only
    sendmail_path = /usr/sbin/sendmail -t -i
现在你准备好了。

发送纯文本的电子邮件
PHP 使用 mail() 函数来发送电子邮件。这个函数需要三个强制参数指定收件人的电子邮件地址，消息和实际消息的主题另外还有其他两个可选参数。

    mail( to, subject, message, headers, parameters );
这是每个参数的描述。

参数	描述
to	必需的。指定邮件的接收/接收器
subject	必需的。指定电子邮件的主题。该参数不能包含任何换行字符
message	必需的。定义要发送的消息。每一行应该分离低频(\ n)。行不得超过70个字符
headers	可选的。指定附加头,从Cc和Bcc。附加头应该被CRLF(\ r \ n) 分开
parameters	可选的。指定一个附加参数到sendmail的程序
尽快 PHP 调用邮件函数将试图发送电子邮件，那么成功它将返回 true，如果失败它将返回 false。

可以指定为多个收件人在 mail() 函数的第一个参数在一个逗号分隔的列表中。

示例
以下示例将发送 HTML 电子邮件消息到 xyz@somedomain.com。你可以以这样一种方式编写程序的代码，它应该接收来自用户的所有内容，然后应该发送一个电子邮件。

    <html>
    <head>
    <title>Sending email using PHP</title>
    </head>
    <body>
    <?php
       $to = "xyz@somedomain.com";
       $subject = "This is subject";
       $message = "This is simple text message.";
       $header = "From:abc@somedomain.com \r\n";
       $retval = mail ($to,$subject,$message,$header);
       if( $retval == true )  
       {
          echo "Message sent successfully...";
       }
       else
       {
          echo "Message could not be sent...";
       }
    ?>
    </body>
    </html>
发送 HTML 电子邮件
当你使用 PHP 发送一个文本信息所有的内容将被视为简单的文本。即使你包含 HTML 标签在一个文本消息时，它将显示简单的文本和 HTML 标记将不会通过 HTML 语法显示格式化。但 PHP 提供了选择发送 HTML 消息按照实际 HTML 消息。

发送电子邮件消息时您可以指定一个 Mime 版本，内容类型和字符集来发送 HTML 电子邮件。

例如
以下示例将 HTML 电子邮件消息发送到 xyz@somedomain.com 将它复制到 afgh@somedomain.com。你可以以编写这个程序的代码的方式从用户接收所有的内容，然后发送一个电子邮件。

    <html>
    <head>
    <title>Sending HTML email using PHP</title>
    </head>
    <body>
    <?php
       $to = "xyz@somedomain.com";
       $subject = "This is subject";
       $message = "<b>This is HTML message.</b>";
       $message .= "<h1>This is headline.</h1>";
       $header = "From:abc@somedomain.com \r\n";
       $header = "Cc:afgh@somedomain.com \r\n";
       $header .= "MIME-Version: 1.0\r\n";
       $header .= "Content-type: text/html\r\n";
       $retval = mail ($to,$subject,$message,$header);
       if( $retval == true )
       {
          echo "Message sent successfully...";
       }
       else
       {
          echo "Message could not be sent...";
       }
    ?>
    </body>
    </html>
用电子邮件发送附件
发送电子邮件与混合内容要求设置内容类型头到多部分/混合。然后可以在在边界里指定文本和附件部分。

边界始于两个连字符后跟一个惟一的编号这个编号不可以出现在电子邮件中的一部分。一个 PHP 函数 md5() 用于创建一个 32 位十六进制数唯一的号码。最终的边界表示电子邮件的最后部分也必须有两个连字符结束。

附加文件应该用 base64_encode () 函数编码进行安全传输和最好用 chunk_split() 函数分成块。这增加了 \r\n 定期内部文件，正常每 76 个字符。

下面的示例将发送文件 /tmp/test.txt 作为附件。你可以编写代码程序接收一个上传文件并将其发送。

    <html>
    <head>
    <title>Sending attachment using PHP</title>
    </head>
    <body>
    <?php
      $to = "xyz@somedomain.com";
      $subject = "This is subject";
      $message = "This is test message.";
      # Open a file
      $file = fopen( "/tmp/test.txt", "r" );
      if( $file == false )
      {
         echo "Error in opening file";
         exit();
      }
      # Read the file into a variable
      $size = filesize("/tmp/test.txt");
      $content = fread( $file, $size);

      # encode the data for safe transit
      # and insert \r\n after every 76 chars.
      $encoded_content = chunk_split( base64_encode($content));

      # Get a random 32 bit number using time() as seed.
      $num = md5( time() );

      # Define the main headers.
      $header = "From:xyz@somedomain.com\r\n";
      $header .= "MIME-Version: 1.0\r\n";
      $header .= "Content-Type: multipart/mixed; ";
      $header .= "boundary=$num\r\n";
      $header .= "--$num\r\n";

      # Define the message section
      $header .= "Content-Type: text/plain\r\n";
      $header .= "Content-Transfer-Encoding:8bit\r\n\n";
      $header .= "$message\r\n";
      $header .= "--$num\r\n";

      # Define the attachment section
      $header .= "Content-Type:  multipart/mixed; ";
      $header .= "name=\"test.txt\"\r\n";
      $header .= "Content-Transfer-Encoding:base64\r\n";
      $header .= "Content-Disposition:attachment; ";
      $header .= "filename=\"test.txt\"\r\n\n";
      $header .= "$encoded_content\r\n";
      $header .= "--$num--";

      # Send email now
      $retval = mail ( $to, $subject, "", $header );
      if( $retval == true )
       {
          echo "Message sent successfully...";
       }
       else
       {
          echo "Message could not be sent...";
       }
    ?>
    </body>
    </html>
你尝试所有上面的示例。如果你面对任何问题，那么你可以在论坛发布这一问题。



文件上传

PHP 脚本允许用户使用 HTML 格式上传文件到服务器上。最初的文件被上传到一个临时目录中，随后 PHP 脚本将其转移到最终目录中。

在 phpinfo.php 页面中信息描述用于文件上传的临时目录为 upload_tmp_dir，并且允许最大上传文件为upload_max_filesize。这些参数被设置在 PHP 配置文件 PHP.ini 中

上传文件步骤如下:　 　

用户打开页面，其中包含 HTML 文本文件表单，浏览按钮和提交按钮。　　　　
用户单击浏览按钮并从本地电脑上选择文件上传。　
选中文件的完整路径出现在文本框中，然后单击提交按钮。　　　　
所选文件被发送到服务器上的临时目录中。　　　　
指定为形式的 PHP 脚本处理程序在表单的动作属性检查文件已经到达后，然后将文件复制到目标目录中。
PHP 脚本确认上传成功。
通常，在临时和最终的位置中，写入文件设置权限为允许是很有必要的。如果被设置为只读那么过程将会失败 一个上传文件可以是一个文本文件或图像文件或任何其他文档。

创建上传表单
下面 HTML 代码创建了一个上传表单。这种表单属性设置为 post，enctype属性设置为 multipart/from-data

    <html>
    <head>
    <title>File Uploading Form</title>
    </head>
    <body>
    <h3>File Upload:</h3>
    Select a file to upload: <br />
    <form action="/php/file_uploader.php" method="post"
                            enctype="multipart/form-data">
    <input type="file" name="file" size="50" />
    <br />
    <input type="submit" value="Upload File" />
    </form>
    </body>
    </html>
创建一个上传脚本
有一个全局 PHP 变量名为 $_FILES。这个变量是二维数组，保留了所有上传文件的相关信息。因此，如果分配给在上传表单输入值的名称 File，那么 PHP 将创建 5 个变量：

$_FILES['file']['tmp_name']-——上传文件在 web 服务器上的临时目录。　　　　
$_FILES['file']['name']——上传文件的真实名称。　　　　
$_FILES['file']['size']——上传文件的大小以字节为单位。　　　　
$_FILES['file']['type']——上传文件的 MIME 类型。　　　　
$_FILES['file']['error']——与此文件上传相关的错误代码。
下面例子中脚本试图复制一个在前一节中列出 HTML 表单上传的文件到 /var/www/html 目录中，这是 PHP 服务器文档的根目录，在完成后它会显示所有文件的细节。请注意，如果您要显示上传文件不要使用二进制文件如图片或 Word 文档。

这里的代码 uploader.php 脚本将处理上传的文件。

    <?php
    if( $_FILES['file']['name'] != "" )
    {
       copy( $_FILES['file']['name'], "/var/www/html" ) or 
               die( "Could not copy file!");
    }
    else
    {
        die("No file specified!");
    }
    ?>
    <html>
    <head>
    <title>Uploading Complete</title>
    </head>
    <body>
    <h2>Uploaded File Info:</h2>
    <ul>
    <li>Sent file: <?php echo $_FILES['file']['name'];  ?>
    <li>File size: <?php echo $_FILES['file']['size'];  ?> bytes
    <li>File type: <?php echo $_FILES['file']['type'];  ?>
    </ul>
    </body>
    </html>
当你将使用表单上传和脚本上传文件时,显示结果如下：

    Uploaded File Info:

    Sent file: uploadedfile.txt
    File size: 2003 bytes
    File type: image/jpg
你自己在网络服务器上尝试上述例子后，如果您有任何问题，请发到论坛上将得到进一步的帮助。



编码标准

基于实践经验每家公司使用的编码标准不同。编码标准是必要的，因为可能有很多开发人员开发不同的模块，如果他们开始创造自己的标准，那么源代码将会变得非常难以管理，将来进而变得难以维护源代码。

使用编码规范原因如下：

你的同伴程序员必须理解你生成的代码。代码标准充当着所有团队破译代码的蓝图。
通过简单和清晰一致的编码可以避免常见的错误。　　　　
如果你修改代码一段时间后，它变得容易理解了。　　　　
其行业标准遵循特定的软件质量标准，可在 PHP 编码中很少有指南。
缩进和线长-使用 4 个空格缩进而不要使用任何标记, 因为不同的计算机使用不同的标记。建议使用大约 75 - 85字符长度，这样代码可读性更好
控制结构-其中包括 if，for，whilte，switch 等。控制语句中控制关键字之间应该有一个空格和半个括号，来区分函数调用。即使在技术可选的情况下同样强烈建议您始终使用花括号。
例如：

    if ((condition1) || (condition2)) {
        action1;
    } elseif ((condition3) && (condition4)) {
        action2;
    } else {
        default action;
    }
您可以编写 switch 语句如下：

    switch (condition) {
    case 1:
        action1;
        break;

    case 2:
        action2;
        break;

    default:
        defaultaction;
        break;
    }
函数调用，调用函数时，应该与函数名、开括号、第一个参数之间没有空格；与逗号和每个参数有空格，与最后一个参数、整括号、分号之间没有空格。请看示例：
    $var = foo($bar, $baz, $quux);
函数定义，函数声明遵循 “BSD /Allman Style”：
    function fooFunction($arg1, $arg2 = '')
    {
        if (condition) {
            statement;
        }
        return $val;
    }
评论——C 语言评论(/ /)和标准 C++ 语言注释(/ /)都可以。使用 Perl/shell 形式的注释(#)是不可以的。

PHP 代码标记——总是使用 < ?php?> 分隔 PHP 代码, 而不是 < ? ?> 速记。这是 PHP 合规所需,也是 PHP 代码在不同的操作系统中设置和安装最便携的方式。

变量名 　　　　
使用所有小写字母　　
使用这个 “_” 为文字分隔符。　　
全局变量预设为 “g”。　　
全局常量应该全部大写以 “_” 分隔。　　
静态变量可以预设为 “s”。
使函数的可重入——函数不要保持静态变量以防止函数不可重入。
一致性声明块——块声明应该一致。
每行一个声明——每行只应该有一个声明，除非声明非常密切相关。
短的方法或函数——方法应该限制代码在一个单独页面的。
编写 PHP 程序时应考虑的可能会更多。在代码编程中，只有你在按照一种代码标准编程下才会有所有的内涵一致的可能性。如果你喜欢与众不同，你可以设计自己的标准。









预定义变量

PHP 在运行的脚本中提供了大量预定义的变量来供使用。PHP提供了一套附加的预定义数组，这些数组变量包含了来自 web 服务器环境和用户输入。这些新的数组被称为超全局变量：

以下所有的变量在全局范围内自动生效：

PHP 超全局变量：

变量	说明
$GLOBALS	包含一个引用变量这就表示其在脚本的所有作用域中都是可用的，变量的名字就是数组的键。
$_SERVER	是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；见下一节的完整列表的所有服务器变量。
$_GET	通过HTTP GET方法传递给当前脚本的变量的关联数组。
$_POST	通过HTTP POST方法传递给当前脚本的变量的关联数组。
$_FILES	通过 HTTP POST 方式上传到当前脚本的项目的数组。
$_REQUEST	一个关联数组包含了 $_GET，$_POST 和 $_COOKIE 的数组。
$_COOKIE	通过 HTTP Cookies 方式传递给当前脚本的变量的关联数组。
$_SESSION	通过会话方式使用于当前脚本的变量的关联数组。
$_PHP_SELF	包含一个PHP脚本的文件名的字符串。
$php_errormsg	是一个包含文本的最后一个PHP生成的错误消息的变量。
服务器变量：$ _SERVER
$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目。

SOFTWARE
变量	说明
$_SERVER['PHP_SELF']	当前执行脚本的文件名，与 document root 有关。
$_SERVER['argv']	传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含查询字符串。
$_SERVER['argc']	包含命令行模式下传递给该脚本的参数的数目(如果运行在命令行模式下)。
$_SERVER['GATEWAY_INTERFACE']	服务器使用的 CGI 规范的版本；例如，“CGI/1.1”。
$_SERVER['SERVER_ADDR']	当前运行脚本所在的服务器的 IP 地址。
$_SERVER['SERVER_NAME']	当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。
$_SERVER['SERVER_SOFTWARE']	服务器标识字符串，在响应请求时的头信息中给出。
$_SERVER['SERVER_PROTOCOL']	请求页面时通信协议的名称和版本。例如，“HTTP/1.0”。
$_SERVER['REQUEST_METHOD']	访问页面使用的请求方法；例如，“GET”, “HEAD”，“POST”，“PUT”。
$_SERVER['REQUEST_TIME']	请求开始时的时间戳。从 PHP 5.1.0 起可用。
$_SERVER['QUERY_STRING']	query string（查询字符串），如果有的话，通过它进行页面访问。
$_SERVER['DOCUMENT_ROOT']	当前运行脚本所在的文档根目录。在服务器配置文件中定义。
$_SERVER['HTTP_ACCEPT']	当前请求头中 Accept: 项的内容，如果存在的话。
$_SERVER['HTTP_ACCEPT_CHARSET']	当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：“iso-8859-1,*,utf-8”。
$_SERVER['HTTP_ACCEPT_ENCODING']	当前请求头中 Accept-Encoding: 项的内容，如果存在的话。例如：“gzip”。
$_SERVER['HTTP_ACCEPT_LANGUAGE']	当前请求头中 Accept-Language: 项的内容，如果存在的话。例如：“en”。
$_SERVER['HTTP_CONNECTION']	当前请求头中 Connection: 项的内容，如果存在的话。例如：“Keep-Alive”。
$_SERVER['HTTP_HOST']	当前请求头中 Host: 项的内容，如果存在的话。
$_SERVER['HTTP_REFERER']	页面的地址(如果有的话),将当前页面的用户代理。
$_SERVER['HTTP_USER_AGENT']	该字符串表明了访问该页面的用户代理的信息。一个典型的例子是：Mozilla/4.5 [en] (X11; U; Linux 2.2.9 i586)。
$_SERVER['HTTPS']	如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。
$_SERVER['REMOTE_ADDR']	浏览当前页面的用户的 IP 地址。
$_SERVER['REMOTE_HOST']	浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。
$_SERVER['REMOTE_PORT']	服务器机器上的端口使用的web服务器进行通信。为默认设置,这将是“80”。
$_SERVER['SCRIPT_FILENAME']	当前执行脚本的绝对路径。
$_SERVER['SERVER_ADMIN']	该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。
$_SERVER['SERVER_PORT']	Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。
$_SERVER['SERVER_SIGNATURE']	包含了服务器版本和虚拟主机名的字符串。
$_SERVER['PATH_TRANSLATED']	当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。
$_SERVER['SCRIPT_NAME']	包含当前脚本的路径。这是有用的页面需要指向自己。
$_SERVER['REQUEST_URI']	给定的URI来访问这个页面;例如,/ index . html。
$_SERVER['PHP_AUTH_DIGEST']	当运行在Apache模块做消化HTTP身份验证这个变量设置为发送的“授权”头端。
$_SERVER['PHP_AUTH_USER']	运行在Apache和IIS(ISAPI PHP 5)作为HTTP身份验证模块做这个变量设置为用户提供的用户名。
$_SERVER['PHP_AUTH_PW']	当运行在Apache和IIS(ISAPI PHP 5)作为HTTP身份验证模块做这个变量设置为用户提供的密码。
$_SERVER['AUTH_TYPE']	当运行在Apache HTTP身份验证模块做这个变量设置为身份验证类型。





错误处理

错误处理是发现程序运行过程中出现的错误，然后采取适当的行动加以处理。如果你能妥善处理错误就可能避免许多无法预料的后果的发生。

在 PHP 处理一个非常简单的错误。

使用 die() 函数
当你写 PHP 程序时在运行之前你应该检查所有可能的错误条件并在必要时采取适当的行动。

试试下面的例子，没有/tmp/test.xt，这个文件，看产生什么错误。

    <?php
    if(!file_exists("/tmp/test.txt"))
     {
     die("File not found");
     }
    else
     {
     $file=fopen("/tmp/test.txt","r");
     print "Opend file sucessfully";
     }
     // Test of the code here.
    ?>
这种方式你可以编写出高效的代码。使用以上技术可以使你的程序产生错误时，可以停止你的程序时并且显示更有意义的和用户友好错误信息。

定义自定义错误处理函数
你可以写自己定义的函数来处理错误，PHP 给你提供了一个定义错误处理函数框架。

这个函数能够操作至少两个参数(错误级别和错误消息)，但也可以接受五个参数(可选：文件，行编号和错误上下文):

语法

    error_function(error_level,error_message, error_file,error_line,error_context); 
参数	说明
error_level	必需。为用户定义的错误规定错误报告级别。必须是一个值数。
error_message	必需。为用户定义的错误规定错误消息。
error_file	可选。规定错误在其中发生的文件名。
error_line	可选。规定错误发生的行号。
error_context	可选。规定一个数组，包含了当错误发生时在用的每个变量以及它们的值。
错误报告级别
这些错误报告级别是不同类型的错误可以使用用户定义的错误处理程序。这些值使用|操作符结合使用

值	常量	描述
1	E_ERROR	致命的运行时错误。停止执行脚本
2	E_WARNING	非致命的运行时错误。不暂停脚本执行。
4	E_PARSE	编译时解析错误。解析错误只能由解析器生成。
8	E_NOTICE	运行时通知。脚本发现可能有错误发生，但也可能在脚本正常运行时发生。
16	E_CORE_ERROR	致命的错误发生在PHP的初始启动。
32	E_CORE_WARNING	非致命的运行时错误。这发生在PHP的初始启动。
256	E_USER_ERROR	致命的用户生成的错误。这类似于程序员使用 PHP 函数 trigger_error() 设置的 E_ERROR。
512	E_USER_WARNING	非致命的用户生成的警告。这类似于程序员使用 PHP 函数 trigger_error() 设置的 E_WARNING。
1024	E_USER_NOTICE	用户生成的通知。这类似于程序员使用 PHP 函数 trigger_error() 设置的 E_NOTICE。
2048	E_STRICT	运行时通知。启用PHP建议修改您的代码将确保代码的最好的互操作性和兼容性。
4096	E_RECOVERABLE_ERROR	可捕获的致命错误。类似 E_ERROR，但可被用户定义的处理程序捕获。(参见 set_error_handler())
8191	E_ALL	所有错误和警告，除级别 E_STRICT 以外。（在 PHP 6.0，E_STRICT 是 E_ALL 的一部分）
所有上述错误级别可以使用 PHP 内置库函数设置表中定义的任意值。级别是任何水平高于表中定义的值。

    int error_reporting ( [int $level] )
下面是你可以创建一个错误处理功能函数：

    <?php
    function handleError($errno, $errstr,$error_file,$error_line)
    { 
     echo "<b>Error:</b> [$errno] $errstr - $error_file:$error_line";
     echo "<br />";
     echo "Terminating PHP Script";
     die();
    }
    ?>
你一旦定义自定义错误处理程序，您需要使用 PHP 内置库 set_error_handler 函数来设置它。现在让我们通过调用一个不存在的函数来检查我们的示例：

    <?php
    error_reporting( E_ERROR );
    function handleError($errno, $errstr,$error_file,$error_line)
    {
     echo "<b>Error:</b> [$errno] $errstr - $error_file:$error_line";
     echo "<br />";
     echo "Terminating PHP Script";
     die();
    }
    //set error handler
    set_error_handler("handleError");

    //trigger error
    myFunction();
    ?>
异常处理
PHP 5 提供了一种新的面向对象的错误处理方法。异常处理非常重要，它提供了一个更好的控制错误处理机制。

让我们解释这些新关键字相关的异常。

Try - 使用异常的函数应该位于 "try" 代码块内。如果没有触发异常，则代码将照常继续执行。但是如果异常被触发，会抛出一个异常。
Throw - 这里规定如何触发异常。每一个 "throw" 必须对应至少一个 "catch"。
Catch - "catch" 代码块会捕获异常，并创建一个包含异常信息的对象。
当将抛出一个异常，代码语句不会被执行后，和 PHP 将试图找到第一个匹配的 catch 代码块。如果没有捕获到异常，PHP 将会发布一个致命的错误“未捕获异常……”。

需要进行异常处理的代码应该放入 try 代码块内，以便捕获潜在的异常。
每个 try 或 throw 代码块必须至少拥有一个对应的 catch 代码块。
使用多个 catch 代码块可以捕获不同种类的异常。
异常可以在 try 代码块内的 catch 代码块中再次抛出（re-thrown）异常。
实例

下面是一段代码，复制并粘贴这段代码到一个文件中并验证结果。

    <?php
    try {
        $error = 'Always throw this error';
        throw new Exception($error);

        // Code following an exception is not executed.
        echo 'Never executed';

    } catch (Exception $e) {
        echo 'Caught exception: ',  $e->getMessage(), "\n";
    }

    // Continue execution
    echo 'Hello World';
    ?>
在上面的例子中使用 $ e - > getMessage函数得到错误消息。在使用异常类时有以下功能函数可以使用：

getMessage()- 得到异常的消息
getCode() – 异常的代码块
getFile() – 异常的源文件名称
getLine() – 异常的文件行号
getTrace() – 追踪机制
getTraceAsString() – 格式化追踪的字符串
创建自定义异常处理程序

你可以创建自定义异常处理程序。使用以下函数来设置一个用户自定义的异常处理程序函数。

    string set_exception_handler ( callback $exception_handler ) 
这里未捕获的异常发生时调用名称被称为 exception_handler 函数。必须定义此函数之前调用set_exception_handler()。

例子：

    <?php
    function exception_handler($exception) {
      echo "Uncaught exception: " , $exception->getMessage(), "\n";
    }

    set_exception_handler('exception_handler');

    throw new Exception('Uncaught Exception');

    echo "Not Executed\n";
    ?>




错误调试

项目程序第一次运行时很少有正常工作的。很多程序触发 PHP 错误机制并且产生相应的错误消息。你可以决定这些错误消息在那里被触发，也可以将错误消息连同其他程序输出到 web 浏览器页面。也可以包括在 web 服务器错误日志里。

为了使错误信息显示在浏览器中,您需要设置配置文件 display_errors 配置指令为 on (打开模式)。将错误发送到 web 服务器错误日志中，log_errors 设置为 on。如果你想在这两个地方都得到错误消息，你可以配置配置文件都为 on。

PHP 为 error_reporting 设置定义了一些常量可以使用，某些类型的错误会被报道：E_ALL(所有错误严格通知除外)，E_PARSE(解析错误)，E_ERROR(致命错误)，E_WARNING(警告)，E_NOTICE(提示)和E_STRICT (严格的通知)。　　

编写 PHP 程序，使用 PHP-aware BBEdit 和 Emacs 的编辑器是一个好主意。这些编辑器的共同特点之一就是语法高亮显示。你改变你的程序的不同部分，颜色基于这些部分会随之而改变。例如，字符串是粉红色的，关键词等是蓝色的，评论都是灰色的，变量是黑色的。

另外一个特性是引用要和括号匹配，这有助于确保你的引用和括号是成套配对的。当你输入一个关闭分隔符}时编辑器会自动提示开放{匹配。

有以下几点需要被应用当你调试您的程序时：

缺少分号——每个 PHP 语句必须以分号(;)结束。PHP 不会停止执行程序阅读，直到执行到一个分号。如果你离开一行的以分号结束时，PHP 程序会继续向下执行程序。
值不等价——当你对两个值是做比较的时，你需要使用两个等号(==)。使用一个等号是一种常见的错误。
敲错变量名称——如果你拼错变量名称，然后 PHP 会把它作为一个刚声明的变量来使用。记住：PHP，变量是去区分大小写的。
$ 符号—— 一个 $ 符号由于粗心忘记写了这时很难发现，但至少它通常会导致一个错误消息，你会通过这个错误提示知道去哪里找问题。
引用的问题—— 你或多或少存在错误引用的问题。所以检查平衡数量的引用。
遗忘的括号和花括号——他们应该总是成对。
数组索引——所有数组应该开始从 0，而不是 1。
尽管如此，妥善处理所有的错误信息和直接到系统日志文件中跟踪消息，这样如果发生任何错误，那么它将被记录到系统日志文件，你将很快找到并能够调试这个问题。







AJAX

AJAX 是什么?
AJAX 代表异步 JavaScript 和 XML。AJAX 是一种新技术，它是在 XML、HTML、CSS 和 Java 帮助下可以创建更好、更快、交互式 web 应用程序的脚本语言。
传统 web 应用程序使用同步请求从服务器传送信息。这意味着你填写表格，点击提交，获得定向到一个新的从服务器获取信息页面。
使用 AJAX 提交按钮被按下时，JavaScript 将发送一个请求到服务器,解释结果和更新当前屏幕。在纯粹意义上，用户甚至不会知道什么时候把请求传送到服务器上。
PHP and AJAX 例子
明确说明使用 AJAX 和 PHP 是非常容易的从数据库中获取信息,我们要在 “ajax.html” 建立动态 MySQL 查询和显示结果。但在我们继续进行工作之前，让 AJAX 做下工作。可以使用以下命令创建一个表。

注释：我们确保您有足够的权限来执行 MySQL 操作：

    CREATE TABLE `ajax_example` (
      `name` varchar(50) NOT NULL,
      `age` int(11) NOT NULL,
      `sex` varchar(1) NOT NULL,
      `wpm` int(11) NOT NULL,
      PRIMARY KEY  (`name`)
    ) 
现在使用以下 SQL 语句将以下数据转储到此表：

    INSERT INTO `ajax_example` VALUES ('Jerry', 120, 'm', 20);
    INSERT INTO `ajax_example` VALUES ('Regis', 75, 'm', 44);
    INSERT INTO `ajax_example` VALUES ('Frank', 45, 'm', 87);
    INSERT INTO `ajax_example` VALUES ('Jill', 22, 'f', 72);
    INSERT INTO `ajax_example` VALUES ('Tracy', 27, 'f', 0);
    INSERT INTO `ajax_example` VALUES ('Julie', 35, 'f', 90);
客户端 HTML 文件
现在可以让我们的客户端 HTML 文件创建 ajax。如下是 html 和它的代码：

s<html>
<body>
<script language="javascript" type="text/javascript">
<!-- 
//Browser Support Code
function ajaxFunction(){
 var ajaxRequest;  // The variable that makes Ajax possible!

 try{
   // Opera 8.0+, Firefox, Safari
   ajaxRequest = new XMLHttpRequest();
 }catch (e){
   // Internet Explorer Browsers
   try{
      ajaxRequest = new ActiveXObject("Msxml2.XMLHTTP");
   }catch (e) {
      try{
         ajaxRequest = new ActiveXObject("Microsoft.XMLHTTP");
      }catch (e){
         // Something went wrong
         alert("Your browser broke!");
         return false;
      }
   }
 }
 // Create a function that will receive data 
 // sent from the server and will update
 // div section in the same page.
 ajaxRequest.onreadystatechange = function(){
   if(ajaxRequest.readyState == 4){
      var ajaxDisplay = document.getElementById('ajaxDiv');
      ajaxDisplay.innerHTML = ajaxRequest.responseText;
   }
 }
 // Now get the value from user and pass it to
 // server script.
 var age = document.getElementById('age').value;
 var wpm = document.getElementById('wpm').value;
 var sex = document.getElementById('sex').value;
 var queryString = "?age=" + age ;
 queryString +=  "&wpm=" + wpm + "&sex=" + sex;
 ajaxRequest.open("GET", "ajax-example.php" + 
                              queryString, true);
 ajaxRequest.send(null); 
}
//-->
</script>
<form name='myForm'>
Max Age: <input type='text' id='age' /> <br />
Max WPM: <input type='text' id='wpm' />
<br />
Sex: <select id='sex'>
<option value="m">m</option>
<option value="f">f</option>
</select>
<input type='button' onclick='ajaxFunction()' 
                              value='Query MySQL'/>
</form>
<div id='ajaxDiv'>Your result will display here</div>
</body>
</html>
注意：查询中传递变量的方式必须遵循 HTTP 标准和形式。

    URL?variable1=value1;&variable2=value2;
服务器端 PHP 文件
现在你的客户端脚本已经准备好了。现在我们必须编写服务器端脚本将获取的 age， wpm 和 sex 从数据库取出并将其发送回客户端。把以下代码放入到 “ajax-example.php” 文件中

<?php
$dbhost = "localhost";
$dbuser = "dbusername";
$dbpass = "dbpassword";
$dbname = "dbname";
    //Connect to MySQL Server
mysql_connect($dbhost, $dbuser, $dbpass);
    //Select Database
mysql_select_db($dbname) or die(mysql_error());
    // Retrieve data from Query String
$age = $_GET['age'];
$sex = $_GET['sex'];
$wpm = $_GET['wpm'];
    // Escape User Input to help prevent SQL Injection
$age = mysql_real_escape_string($age);
$sex = mysql_real_escape_string($sex);
$wpm = mysql_real_escape_string($wpm);
    //build query
$query = "SELECT * FROM ajax_example WHERE sex = '$sex'";
if(is_numeric($age))
    $query .= " AND age <= $age";
if(is_numeric($wpm))
    $query .= " AND wpm <= $wpm";
    //Execute query
$qry_result = mysql_query($query) or die(mysql_error());

    //Build Result String
$display_string = "<table>";
$display_string .= "<tr>";
$display_string .= "<th>Name</th>";
$display_string .= "<th>Age</th>";
$display_string .= "<th>Sex</th>";
$display_string .= "<th>WPM</th>";
$display_string .= "</tr>";

// Insert a new row in the table for each person returned
while($row = mysql_fetch_array($qry_result)){
    $display_string .= "<tr>";
    $display_string .= "<td>$row[name]</td>";
    $display_string .= "<td>$row[age]</td>";
    $display_string .= "<td>$row[sex]</td>";
    $display_string .= "<td>$row[wpm]</td>";
    $display_string .= "</tr>";

}
echo "Query: " . $query . "<br />";
$display_string .= "</table>";
echo $display_string;
?>



XML

XML 是一种扩展标记语言，看起来很像 HTML。XML 文档是纯文本，包含分隔符<和>标签。XML 和 HTML 之间有两大不同：

XML 不用定义一组特定的标签来作为规范来使用。
XML 文档结构非常严谨。
使用 XML 比 HTML 更自由更随意。HTML 有一组特定的标记：<a> </a>标记来定义一个链接，<p> 标签表示开始一段等等。然而，XML 文档可以使用任何你想要的标签。把<rating> </rating>可以用来标记电影，<height></height>可以用来标记某人的高度。因此 XML 给你选择自己想要的标签。

XML 文档结构时要求很严格。HTML 让你松弛有度的打开和关闭标签。但这并不是 XML 的情况。

HTML 列表不是有效的 XML
    <ul>
    <li>Braised Sea Cucumber
    <li>Baked Giblets with Salt
    <li>Abalone with Marrow and Duck Feet
    </ul>
这不是一个有效的 XML 文档，因为没有关闭标签 </li>来匹配的三个打开的 <li> 标签。XML 文档中的每个打开标签都必须关闭标签相匹配。

解析一个 XML 文档
PHP 5 的新增加的 SimpleXML 模块使得解析 XML 文档更加简单方便。它将 XML 文档转换为一个对象，提供结构化访问 XML。

从 XML 文档中创建一个 SimpleXML 对象将其存储在一个字符串中，然后将字符串传递给 smplexml_load_string() 函数。它会返回一个 SimpleXML 对象。

例子
运行以下事例：

    <?php

    $channel =<<<_XML_
    <channel>
    <title>What's For Dinner<title>
    <link>http://menu.example.com/<link>
    <description>Choose what to eat tonight.</description>
    </channel>
    _XML_;

    $xml = simplexml_load_string($channel);
    print "The $xml->title channel is available at $xml->link. ";
    print "The description is \"$xml->description\"";
    ?>
它将会产生以下结果：

    The What's For Dinner channel is available at http://menu.example.com/. The description is "Choose what to eat tonight." 
注意: 如果你有一个 XML 内容文件您可以使用函数 simplexml_load_file(filename)。

为了更详细的了解 XML 解析函数请察看 PHP 函数。

XML 文档的生成
SimpleXML 解析现有 XML 文档非常快，但你不能用它来创建一个新的 xml 文档。

最简单的生成一个 XML 文档的方法是建立一个 PHP 数组来影射 XML 的结构，然后遍历该数组，打印每个元素与适当的格式。

例子

运行以下实例：

    <?php

    $channel = array('title' => "What's For Dinner",
                     'link' => 'http://menu.example.com/',
                     'description' => 'Choose what to eat tonight.');
    print "<channel>\n";
    foreach ($channel as $element => $content) {
       print " <$element>";
       print htmlentities($content);
       print "</$element>\n";
    }
    print "</channel>";
    ?>
上述代码将会产生以下结果：

    <channel>
    <title>What's For Dinner</title>
    <link>http://menu.example.com/</link>
    <description>Choose what to eat tonight.</description>
    </channel></html>




面向对象

我们可以想象我们的宇宙是由不同的对象组成，像太阳，地球，月亮等等。同样我们可以想象我们的车由不同的组件组成如车轮，转向盘，齿轮等。同样有面向对象编程概念，假设一切作为对象使用不同的对象实例化一个事物。

面向对象的概念
在我们进入讲述细节之前，让我们首先定义面向对象编程相关的重要术语。

类：这是一个编程定义的数据类型,包括本地的方法以及本地数据。你能想到的一个类模板制作许多相同类型的实例(或类)的对象。

对象：一个单独的数据结构用来定义的一个类的实例。你定义一个类,然后让许多对象属于它。对象也被称为实例。

成员变量：这是在类的内部定义的变量。这些数据对于外部类是不可见的,但是可以通过成员函数来访问。对象一旦创建这些变量被称该对象的属性。

成员函数：这些函数定义在一个类,用于访问对象的数据。

继承：当一个类被定义为继承一个已经存在的父类，我们称这个类为继承类，这里继承类可以使用父类的一些成员函数和变量。

父类：一个类被另一个类继承。这个类也被称为基类或超类。

子类：一个类继承另一个类。这个类也被称为一个子类或派生类

多态性：这是一个面向对象的概念，相同的函数可以用于不同的目的。例如函数名仍将是相同的，但它采取不同的数量的参数,可以做不同的任务，完成不同的工作。

重载：一种多态性的部分指在所有的运算符有不同的实现取决于他们的类型参数。同样的函数也可以重载伴随着不同的实现。

数据抽象：任何表示的数据的实现细节是隐藏(抽象)。

封装：是指一个概念,我们的所有数据和成员函数封装在一起,形成一个对象

构造函数：指一个特殊的函数类型可以被自动调用，构造函数的类会在每次创建新对象时先调用此方法。

析构函数：指一个特殊的函数类型可以被自动调用，会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。
定义的 PHP 类
在 PHP 中定义一个新类的一般形式如下：

    <?php
    class phpClass{
       var $var1;
       var $var2 = "constant string";
       function myfunc ($arg1, $arg2) {
          [..]
       }
       [..]
    }
    ?>
这是每一行的描述：

定义类形式 Class，后面是您想要定义的类的名称。
一组花括号包含任意数量的变量声明和函数定义。
变量声明开始使用 var 的特殊形式，紧随其后的是一个传统的 $ 变量名；他们可能也有一个初始化分配一个常量值。
函数定义看起来很像独立的 PHP 函数，但该类和将被用于设置和访问对象数据。
例子

这里是一个例子定义了一个书籍类型类：

    <?php
    class  Books{
        /* Member variables */
        var $price;
        var $title;
        /* Member functions */
        function setPrice($par){
           $this->price = $par;
        }
        function getPrice(){
           echo $this->price ."<br/>";
        }
        function setTitle($par){
           $this->title = $par;
        }
        function getTitle(){
           echo $this->title ." <br/>";
        }
    }
    ?>
变量 $this 是一个特殊的变量，它指的是同一个对象，本身。

用 PHP 创建对象
你一旦定义好你的类，那么您可以创建许多对象。下面是一个例子，如何使用 new 操作符创建对象。

    $physics = new Books;
    $maths = new Books;
    $chemistry = new Books;
在这里，我们已经创建了三个对象，这些对象是相互独立的，他们有自己的单独存在的空间。接下来，我们将看到如何访问成员函数和成员变量的过程。

调用成员函数
创建对象后，您将能够使用相关的对象调用成员函数。一个成员函数将能够处理相关对象的成员变量。

下面的例子显示了如何通过调用成员函数设置标题和价格三本书。

    $physics->setTitle( "Physics for High School" );
    $chemistry->setTitle( "Advanced Chemistry" );
    $maths->setTitle( "Algebra" );

    $physics->setPrice( 10 );
    $chemistry->setPrice( 15 );
    $maths->setPrice( 7 );
现在你调用另一个成员函数获取设置在上面的例子的值：

    $physics->getTitle();
    $chemistry->getTitle();
    $maths->getTitle();
    $physics->getPrice();
    $chemistry->getPrice();
    $maths->getPrice();   
这将会产生以下结果：

    Physics for High School
    Advanced Chemistry
    Algebra
    10
    15
    7
构造函数
构造函数是特殊类型的函数自动创建一个对象时函数的功能会自动执行。所以我们充分利用这个行为，通过构造函数初始化很多功能。PHP 提供了一个特殊的函数叫做 __construct()来定义一个构造函数。你可以把参数传递到构造函数中。以下示例将为书籍类，在创建对象的时候它将创建一个构造函数用来初始化价格和标题这本书。

    function __construct( $par1, $par2 ){
       $this->price = $par1;
       $this->title = $par2;
    }
现在我们不需要调用设置好的函数分别设置价格和标题。我们可以初始化这两个成员变量只在创建对象的时候。检查以下例子：

    $physics = new Books( "Physics for High School", 10 );
    $maths = new Books ( "Advanced Chemistry", 15 );
    $chemistry = new Books ("Algebra", 7 );

    /* Get those set values */
    $physics->getTitle();
    $chemistry->getTitle();
    $maths->getTitle();

    $physics->getPrice();
    $chemistry->getPrice();
    $maths->getPrice();
这将产生以下结果：

    Physics for High School
    Advanced Chemistry
    Algebra
    10
    15
    7
析构函数
您可以定义析构函数：就像定义一个构造函数，析构函数使用函数__destruct()。你可以调用一个析构函数释放所有资源。

继承
PHP 类定义可以使用 extends 关键字继承一个父类。语法如下：

    class Child extends Parent {
     <definition body>
    }
继承的影响是子类 (或派生类或子类)具有以下特点：

自动继承所有父类的成员变量声明。
自动继承父类的成员函数。(默认情况下)像父类一样使用函数。以下例子书类继承和基于需求增加了更多的功能。
    class Novel extends Books{
       var publisher;
       function setPublisher($par){
         $this->publisher = $par;
       }
       function getPublisher(){
         echo $this->publisher. "<br />";
       }
    }
现在除了继承功能，类带了两个额外的成员函数。

函数重载
函数定义子类覆盖与父类中相同的属性及方法名称。在子类中，我们可以修改继承自父类中的方法。

在以下示例中 getPrice 和 getTitle 方法重载。

    function getPrice(){
       echo $this->price . "<br/>";
       return $this->price;
    }
    function getTitle(){
       echo $this->title . "<br/>";
       return $this->title;
    }
公共成员
除非你指定，否则类的属性和方法默认都是公共的。也就是说，他们可能在三种可能的情况下被访问：

从类外声明。
在类中声明。
从另一个类中实现的类声明它。
直到现在我们看到所有成员都作为公共成员。如果你想限制类的成员的可访问性，然后你必须定义类成员为 private 或者 protected。

私有成员
通过指定一个私有成员，你可以限制其访问对象在类外访问它。类的私有成员不能在继承类中调用它，也不能从类外部访问。

私有属性或方法只能在本类内使用：

    class MyClass {
       private $car = "skoda";
       $driver = "SRK";

       function __construct($par) {
          // Statements here run every time
          // an instance of the class
          // is created.
       }
       function myPublicFunction() {
          return("I'm visible!");
       }
       private function myPrivateFunction() {
          return("I'm  not visible outside!");
       }
    }
当 MyClass 类被一个类使用关键字 extends 继承时，myPublicFunction() 方法在子类中是可用的，属性$drive也一样。方法 myPrivateFunction() 和属性 $car 在子类中是不可以被继承的当然也不可以用，因为他们被声明为了私有的。

受保护成员
访问一个受保护的属性或方法并在类中声明它，以及使用关键字 extends 继承该类时。保护成员在两种类型的类之外无法使用。一个类成员可以使用关键字 protected 在其前面。

这是不同版本的 MyClass 类：

    class MyClass {
       protected $car = "skoda";
       $driver = "SRK";

       function __construct($par) {
          // Statements here run every time
          // an instance of the class
          // is created.
       }
       function myPublicFunction() {
          return("I'm visible!");
       }
       protected function myPrivateFunction() {
          return("I'm  visible in child class!");
       }
    }
接口
接口被开发人员定义为提供一个普通的方法名。不同的开发人员可以根据他们不同的需求来分别实现这些接口。你可以说，接口是根据不同的需求被开发人员所实现。

PHP5，可以定义一个接口，如下：

    interface Mail {
       public function sendMail();
    }
然后，另一个类像这样实现该接口：

    class Report implements Mail {
       // sendMail() Definition goes here
    }
常量
一个常量有点像一个变量，它拥有一个值,但实际上更像一个函数，因为常量是永远不变的。一旦你声明一个常量，它不能被改变。

声明一个常量是很容易的，就像下面这个版本的 MyClass，它完成了常量的定义：

    class MyClass {
       const requiredMargin = 1.7;
       function __construct($incomingValue) {
          // Statements here run every time
          // an instance of the class
          // is created.
       }
    }
在这个类中，requiredMargin 是一个常量。它是用关键字 const 声明常量，在任何情况不可以改变他的值 1.7。注意，常量的定义没有 $ 符号，不能像变量那样。

抽象类
抽象类不能被实例化，只能被继承。你用关键字 abstract 声明一个抽象类，就像这样：

当继承一个抽象类的时候，子类必须实现抽象类中的所有的抽象方法，另外，这些方法的可见性必须和抽象类中一样（或更轻松）。

    abstract class MyAbstractClass {
       abstract function myAbstractFunction() {
       }
    }
注意，方法定义在一个抽象类中在方法名称前面之前必须使用关键字 abstract。抽象方法定义在一个非抽象类中是不合法的。

Static关键字
声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。

试运行下面的例子：

    <?php
    class Foo
    {
        public static $my_static = 'foo';

        public function staticValue() {
            return self::$my_static;
        }
    }
    print Foo::$my_static . "\n";
    $foo = new Foo();
    print $foo->staticValue() . "\n";
final 关键字
PHP 5 介绍了这个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。

以下的例子会产生一个致命错误：Cannot override final method BaseClass::moreTesting()。

    <?php
    class BaseClass {
       public function test() {
           echo "BaseClass::test() called<br>";
       }

       final public function moreTesting() {
           echo "BaseClass::moreTesting() called<br>";
       }
    }

    class ChildClass extends BaseClass {
       public function moreTesting() {
           echo "ChildClass::moreTesting() called<br>";
       }
    }
    ?>
调用父类的构造函数
当子类需要一个构造函数时，需要调用父类的构造函数而不是在子类中写一个全新的构造函数，我们需要调用父类的构造函数加一下我们要写的内容，另外在子类的构造函数中做一些初始化是必要的。这是一个简单的例子：

    class Name
    {
       var $_firstName;
       var $_lastName;
       function Name($first_name, $last_name)
       {
         $this->_firstName = $first_name;
         $this->_lastName = $last_name;
       }
       function toString() {
         return($this->_lastName .", " .$this->_firstName);
       }
    }
    class NameSub1 extends Name
    {
       var $_middleInitial;
       function NameSub1($first_name, $middle_initial, $last_name) {
           Name::Name($first_name, $last_name);
           $this->_middleInitial = $middle_initial;
       }
       function toString() {
           return(Name::toString() . " " . $this->_middleInitial);
       }
    }
在上面这个例子中，我们有一个父类(Name)，它里面有一个二个参数的构造函数，在子类中(NameSub1)有一个带有 3 个参数的构造函数。子类 NameSub1 中的构造函数通过调用其父类中的构造函数 Name::Name(传递两个参数)加以使用，然后增加一个额外的属性。同样，NameSub1 定义了 toString() 方法然后重写父类中的 toString() 方法。

注：上例中定义的，可以在子类中定义和父类中相同的构造函数，并且名字名称相同。



PHP 与 C 语言对比

最简单的说法是把 PHP 当做 C，可以嵌入在 HTML 文档中。PHP 很像 C 语言本身，除了没有类型的变量，很多网络特性库被建立，并且一切直接连接到您最喜爱的 Web 服务器。

语句和函数定义的语法应该很熟悉，除了变量总是定义在 $ 之后，函数不需要单独的原型。

这里我们将把 PHP 和 C 一些相似点和不同点进行介绍下：

相似处
语法：一般来说，PHP 和 C 的语法是一样的，C 语言代码简洁紧凑、灵活方便，语句用分号终止。函数调用有相同的结构(my_function(expression1 expression2))，使用语句块花括号({and})。PHP 支持 C 和 C++ 风格的注释(/ / / /)，以及 Perl 和 Shell 脚本风格(#)。

运算符：赋值运算符(=,+=, =等等),布尔操作符(&&,| |,!)比较运算符(<,>, <=, >=, ==, !=)和基本的算术运算符(+, -, , /, %)，这些 C 的操作运算符和 PHP 一样。

控制结构：基本控制结构(if, switch, while, for)和 C 语言基本一样，包括使用 break and continue 关键字。一个明显的区别是， switch 在 PHP 里可以接受字符串作为标识符。

函数名：当你仔细阅读文档，你会看到许多和 C 函数相同的的函数名。
不同之处
$ 符号：所有变量用一个 $ 符号来表示。变量在调用之前不需要声明，他们之间没有本质的类型区别。

类型：PHP 只有两个数值类型：整数(对应于 C 的 long)和双精度类型(对应于 C 的 double)，任意长度的字符串。没有单独的字符类型。

类型转换：类型不是在编译时检查，和类型错误也通常不发生在运行时。相反，变量和值会自动转换类型。

数组：数组在语法层面上类似于 C 的数组的语法，但它们的实现完全不同。他们实际上是关联数组或散列，索引可以是数字或字符串。他们不需要声明或提前分配。

结构类型：在 PHP 中没有结构，部分原因是它们在一起时没有必要都是数组和对象类型。一个 PHP 数组的元素可以是不一致的类型。

没有指针：虽然无类型变量发挥类似的作用，在 PHP 中没有指针。PHP 不支持变量引用。在某种程度上你也可以模拟函数指针，把函数名可以存储在变量和被使用的变量中而不是文字名称。

没有原型：宣布实施之前函数不需要定义，只要可以找到定义函数所在当前文件的代码。

内存管理：PHP 引擎实际上是一个垃圾回收机制(采用引用计数)，在小脚本中运行不需要做任何回收。你应该自由分配新结构——如新的字符串和对象实例。在 PHP5 中，可以定义对象的析构函数，当 PHP 决定你的脚本不再与对象相关时，PHP 析构函数将被调用，PHP 调用它们来将一个对象从内存中销毁，在内存回收。

编译和链接：没有单独的编译 PHP 脚本的步骤。

许可：一般而言，PHP 比 C 更加宽松 (尤其是它的类型系统)，所以会让你容易远离新类型的错误。意想不到的结果比错误更常见。












类／对象函数库 
call_user_method_array()	调用一个用户方法，同时传递参数数组（已废弃）	4
call_user_method()	对特定对象调用用户方法（已废弃）	4
class_exists()	检查类是否已定义	4
get_class_methods()	返回由类的默认属性组成的数组	4
get_class_vars()	返回对象的参数	4
get_class()	返回由已定义类的名字	4
get_declared_classes()	返回由已定义类的名字所组成的数组	4
get_declared_interfaces()	返回一个数组包含所有已声明的接口	5
get_object_vars()	返回由对象属性组成的关联数组	4
get_parent_class()	返回对象或类的父类名	4
interface_exists()	检查接口是否已被定义	5
is_a()	如果对象属于该类或该类是此对象的父类则返回 TRUE	4
is_subclass_of ()	如果此对象是该类的子类，则返回 TRUE	4
method_exists()	检查类的方法是否存在	4
property_exists()	检查对象或类是否具有该属性	5


PHP 字符函数
ctype_alnum()	做字母和数字字符检测	4.0.4
ctype_alpha()	做纯字符检测	4.0.4
ctype_cntrl()	做控制字符检测	4.0.4
ctype_digit()	做纯数字检测	4.0.4
ctype_graph()	做可打印字符串检测，空格除外	4.0.4
ctype_lower()	做小写字符检测	4.0.4
ctype_print()	做可打印字符检测	4.0.4
ctype_punct()	检测可打印的字符是不是不包含空白、数字和字母	4.0.4
ctype_space()	做空白字符检测	4.0.4
ctype_upper()	做大写字母检测	4.0.4
ctype_xdigit()	检测字符串是否只包含十六进制字符	4.0.4




PHP Directory 函数

这些函数提供操纵任何目录。

安装
Directory 函数是 PHP 核心的组成部分。无需安装即可使用这些函数。PHP需要配置——enable-chroot-func选项来启用chroot()函数。

运行时配置
此扩展没有在 php.ini 中定义配置指令。

PHP Directory 常量
PHP：指示支持该常量的最早的 PHP 版本。

常量	说明	PHP
DIRECTORY_SEPARATOR	 	3
PATH_SEPARATOR	 	4
函数列表
PHP: PHP：指示支持该函数的最早的 PHP 版本。

函数	说明	PHP
chdir()	改变当前的目录。	4
chroot()	改变当前进程的根目录。	4.0.4
dir()	打开一个目录句柄，并返回一个对象。	4
closedir()	关闭目录句柄。	4
getcwd()	返回当前目录。	4
opendir()	打开目录句柄。	4
readdir()	返回目录句柄中的条目。	4
rewinddir()	重置目录句柄。	4
scandir()	列出指定路径中的文件和目录。	5
注意:与文件系统相关的更多的函数,检查File System Functions






PHP Error 和 Logging 函数

这些都是处理错误处理和日志记录的函数。它们允许您定义自己的错误处理规则,以及可以修改错误记录的方式。这允许你改变和提高错误报告来满足您的需求。 　　　 使用这些日志记录功能,你可以直接发送消息到其他机器，电子邮件，系统日志，等等；所以你可以有选择地记录和监控您的应用程序和网站的最重要的部分。

安装
error 和 logging 函数是 PHP 核心的组成部分。无需安装即可使用这些函数。

运行时配置
在php.ini中设置会影响这些函数的行为。这些设置定义如下

名称	默认值	可改变的	变更日志
error_reporting	NULL	PHP_INI_ALL	 
display_errors	"1"	PHP_INI_ALL	 
display_startup_errors	"0"	PHP_INI_ALL	版本PHP 4.0.3之后可用
log_errors	"0"	PHP_INI_ALL	 
log_errors_max_len	"1024"	PHP_INI_ALL	版本PHP 4. 3.0之后可用
ignore_repeated_errors	"0"	PHP_INI_ALL	版本PHP 4. 3.0之后可用
ignore_repeated_source	"0"	PHP_INI_ALL	版本PHP 4. 3.0之后可用
report_memleaks	"1"	PHP_INI_ALL	版本PHP 4. 3.0之后可用
track_errors	"0"	PHP_INI_ALL	 
html_errors	"1"	PHP_INI_ALL	PHP_INI_SYSTEM in PHP
docref_root	""	PHP_INI_ALL	版本PHP 4. 3.0之后可用
docref_ext	""	PHP_INI_ALL	版本PHP 4. 3.0之后可用
error_prepend_string	NULL	PHP_INI_ALL	 
error_append_string	NULL	PHP_INI_ALL	 
error_log	NULL	PHP_INI_ALL	 
warn_plus_overloading	NULL	 	版本PHP 4. 0.0不可用
PHP Error 和 Logging 常数
PHP：表明最早版本的PHP支持常数。您可以使用任何常数当你配置了php.ini文件。

值	常量	描述	PHP
1	E_ERROR	致命的运行时错误。错误无法恢复。脚本的执行被中断。	 
2	E_WARNING	非致命的运行时错误。脚本的执行不会中断。	 
4	E_PARSE	编译时语法解析错误。解析错误只应该由解析器生成。	 
8	E_NOTICE	运行时提示。可能是错误，也可能在正常运行脚本时发生。	 
16	E_CORE_ERROR	由 PHP 内部生成的错误。	4
32	E_CORE_WARNING	由 PHP 内部生成的警告。	4
64	E_COMPILE_ERROR	由 Zend 脚本引擎内部生成的错误。	4
128	E_COMPILE_WARNING	由 Zend 脚本引擎内部生成的警告。	4
256	E_USER_ERROR	由于调用 trigger_error() 函数生成的运行时错误。	4
512	E_USER_WARNING	由于调用 trigger_error() 函数生成的运行时警告。	4
1024	E_USER_NOTICE	由于调用 trigger_error() 函数生成的运行时提示。	4
2048	E_STRICT	运行时提示。对增强代码的互用性和兼容性有益。	5
4096	E_RECOVERABLE_ERROR	可捕获的致命错误。（参阅 set_error_handler()）	5
8191	E_ALL	所有的错误和警告，除了 E_STRICT。	5
函数列表
PHP：指示支持该常量的最早的 PHP 版本。

函数	说明	PHP
debug_backtrace()	生成 backtrace。	4
debug_print_backtrace()	输出 backtrace。	5
error_get_last()	获得最后发生的错误。	5
error_log()	向服务器错误记录、文件或远程目标发送一个错误。	4
error_reporting()	规定报告哪个错误。	4
restore_error_handler()	恢复之前的错误处理程序。	4
restore_exception_handler()	恢复之前的异常处理程序。	5
set_error_handler()	设置用户自定义的错误处理函数。	4
set_exception_handler()	设置用户自定义的异常处理函数。	5
trigger_error()	创建用户自定义的错误消息。/td>	4
user_error()	trigger_error() 的别名。	4
